# Как работает WebRTC (и этот код)

WebRTC (Web Real-Time Communication) — это технология, которая позволяет двум браузерам общаться напрямую. Но чтобы они "нашли" друг друга в интернете, им нужна небольшая помощь в начале.

Этот процесс называется **Signaling (Сигналинг)**.

---

## 1. Главная проблема: "Где ты?"

Ваш компьютер не имеет прямого публичного адреса в интернете (обычно). Он находится за роутером (NAT). Ваш друг — тоже.
Если вы просто скажете "подключайся к моему IP 192.168.1.5", друг не сможет этого сделать, потому что этот адрес локальный.

### Решение: ICE Candidates (Кандидаты)

Браузер использует STUN-сервер (мы используем бесплатные от Google), чтобы узнать свой **внешний** IP-адрес и порт.
Эти возможные пути подключения называются **ICE Candidates**.

Оба браузера собирают свои "кандидаты" и должны как-то передать их друг другу.

---

## 2. Процесс подключения (Handshake)

Чтобы соединение состоялось, браузеры должны обменяться не только IP-адресами, но и информацией о том, какие видео-кодеки они поддерживают. Этот формат данных называется **SDP (Session Description Protocol)**.

### Шаг 1: Offer (Предложение)

1.  **Peer A** (тот, кто звонит) создает `RTCPeerConnection`.
2.  Создает **Offer** (SDP-файл: "Я хочу соединиться, у меня есть видео и аудио").
3.  Сохраняет этот Offer в нашу базу данных (Firestore).

### Шаг 2: Answer (Ответ)

1.  **Peer B** (тот, кто отвечает) видит новый Offer в базе.
2.  Принимает его: `setRemoteDescription(offer)`.
3.  Создает **Answer** (SDP-файл: "Ок, я принимаю, мои кодеки такие-то").
4.  Сохраняет Answer в базу.

### Шаг 3: Обмен ICE Candidates (Параллельно)

Пока идет обмен Offer/Answer, браузеры находят возможные пути подключения (через STUN).
Как только браузер находит новый путь (Candidate), он кидает его в базу.
Второй браузер слушает базу, берет кандидата и добавляет себе: `addIceCandidate(candidate)`.

---

## 3. Почему Firebase?

WebRTC **не диктует**, как передавать Offer, Answer и ICE Candidates.
Вы можете продиктовать их по телефону, отправить голубиной почтой или переслать через сервер.

В реальных приложениях используют WebSockets (для мгновенной передачи).
В нашем примере мы используем **Firebase Firestore**, потому что:

1.  Это проще (не нужно писать бэкенд).
2.  Она работает в реальном времени (метод `onSnapshot` вызывает функцию JS сразу, как только в базе что-то меняется).

---

## Схема данных в Firestore

Мы создадим коллекцию `rooms`. Один документ — один звонок.

```json
{
  "offer": { "type": "offer", "sdp": "..." },
  "answer": { "type": "answer", "sdp": "..." },
  // Подколлекция для кандидатов Звонящего
  "callerCandidates": [
    { "candidate": "...", "sdpMid": "...", ... }
  ],
  // Подколлекция для кандидатов Отвечающего
  "calleeCandidates": [
    { "candidate": "...", "sdpMid": "...", ... }
  ]
}
```

## Алгоритм в коде (`VideoRoom.tsx`)

1.  **`user creates room`**:
    - Генерируем ID.
    - Создаем `RTCPeerConnection`.
    - Создаем `offer` -> пишем в Firestore.
    - Слушаем Firestore на наличие `answer`.
    - Слушаем Firestore на наличие `calleeCandidates`.

2.  **`user joins room`**:
    - Читаем `offer` из Firestore -> устанавливаем себе.
    - Создаем `answer` -> пишем в Firestore.
    - Слушаем Firestore на наличие `callerCandidates`.

Как только обмен завершен — видео появляется само собой (P2P магия).
